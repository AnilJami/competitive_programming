\documentclass[10pt,letterpaper]{article}

%---------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
%\usepackage{color}
%---------------------------------------------------------------

\setlength{\topmargin}{-1.0in}
\setlength{\textheight}{9.5in} 
\setlength{\evensidemargin}{0.0in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\textwidth}{6.5in} 

\begin{document}

%---------------------------------------------------------------
\title{Resumen de algoritmos para torneos de programación}
\author{Andrés Mejía}
\date{\today}
%\maketitle
%---------------------------------------------------------------

%---------------------------------------------------------------
\tableofcontents
%\lstlistoflistings
\lstloadlanguages{C++}
%---------------------------------------------------------------
%---------------------------------------------------------------
\section{Teoría de números}
%---------------------------------------------------------------
\subsection{Big mod}

\input{./src/number_theory/bigmod}%.tex

\subsection{Criba de Eratóstenes}
Marca los números primos en un arreglo. Algunos tiempos de ejecución:
\begin{center}
\begin{tabular}{c c}
\hline\hline
SIZE & Tiempo (s) \\ [0.5ex]
\hline
100000 & 0.004 \\
1000000 & 0.078 \\
10000000 & 1.550 \\
100000000 & 14.319 \\ [1ex]
\hline
\end{tabular}
\end{center}

\input{./src/number_theory/criba}%.tex

\subsection{Divisores de un número}
Este algoritmo imprime todos los divisores de un número (en desorden) en O($\sqrt{n}$).
Hasta 4294967295 (máximo \textit{unsigned long}) responde instantaneamente. Se puede
forzar un poco más usando \textit{unsigned long long} pero más allá de $10^{12}$ empieza a
responder muy lento.

\bigskip

\input{./src/number_theory/divisores}%.tex


\section{Grafos}
\subsection{Algoritmo de Dijkstra}
El peso de todas las aristas debe ser no negativo.
\\
\input{./src/grafos/dijkstra}%.tex

\subsection{Minimum spanning tree: Algoritmo de Prim}

\input{./src/grafos/prim}%.tex

\subsection{Minimum spanning tree: Algoritmo de Kruskal}
\input{./src/grafos/kruskal}%.tex

\subsection{Algoritmo de Floyd}
\input{./src/grafos/floyd}%.tex

\subsection{Puntos de articulación}
\input{./src/grafos/puntos_articulacion}%.tex

\section{Programación dinámica}
\subsection{Longest common subsequence}
\input{./src/dp/lcs}%.tex

\section{Geometría}
\subsection{Área de un polígono}
Si P es un polígono simple (no se intersecta a sí mismo) su área está dada por: \\

$ A(P) = \frac{1}{2} \displaystyle\sum_{i=0}^{n-1} (x_{i} \cdot y_{i+1} - x_{i+1} \cdot y_{i}) $ \\

\subsection{Centro de masa de un polígono}
Si P es un polígono simple (no se intersecta a sí mismo) su centro de masa está dado por: \\

$ \displaystyle\bar{C}_{x} = \frac{ \displaystyle\iint_{R} x \, dA }{M} = \frac{1}{6M}\sum_{i=1}^{n} (y_{i+1} - y_{i}) (x_{i+1}^2 + x_{i+1} \cdot x_{i} + x_{i}^2) $

\medskip

$\displaystyle\bar{C}_{y} = \frac{ \displaystyle\iint_{R} y \, dA }{M} = \frac{1}{6M} \sum_{i=1}^{n} (x_{i} - x_{i+1}) (y_{i+1}^2 + y_{i+1} \cdot y_{i} + y_{i}^2)$

\medskip

Donde $ M $ es el área del polígono. \\

Otra posible fórmula equivalente:

$ \displaystyle\bar{C}_{x} = \frac{1}{6A} \sum_{i=0}^{n-1} (x_{i} + x_{i+1}) (x_{i} \cdot y_{i+1} - x_{i+1} \cdot y_{i}) $
$ \displaystyle\bar{C}_{y} = \frac{1}{6A} \sum_{i=0}^{n-1} (y_{i} + y_{i+1}) (x_{i} \cdot y_{i+1} - x_{i+1} \cdot y_{i}) $


\subsection{Convex hull: Graham Scan}
\emph{Complejidad:} $ O(n \log_{2}{n}) $
\input{./src/geometria/grahamscan}%.tex

\subsection{Convex hull: Andrew's monotone chain}
\emph{Complejidad:} $ O(n \log_{2}{n}) $
\input{./src/geometria/monotonechain}%.tex

\subsection{Mínima distancia entre un punto y un segmento}
\input{./src/geometria/distance_point_to_segment}%.tex

\subsection{Mínima distancia entre un punto y una recta}
\input{./src/geometria/distance_point_to_line}%.tex
%---------------------------------------------------------------

\section{Java}
\subsection{Entrada desde entrada estándar}
Este primer método es muy fácil pero es mucho más ineficiente porque utiliza Scanner en vez de BufferedReader: \\
\input{./src/java/io_estandar_easy}%.tex

\bigskip

Este segundo es más rápido: \\
\input{./src/java/io_estandar}%.tex
\subsection{Entrada desde archivo}
\input{./src/java/io_file}%.tex

\section{C++}
\subsection{Entrada desde archivo}
\input{./src/c++/io_file}%.tex

\subsection{Strings con caractéres especiales}
\input{./src/c++/unicode}%.tex

\emph{Nota}: Como alternativa a la función getline, se pueden utilizar las funciones fgetws y fputws, y más adelante swscanf y wprintf:
\input{./src/c++/fgetws}%.tex

\end{document}